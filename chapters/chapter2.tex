\documentclass[../main.tex]{subfiles} 
\begin{document}
\chapter{Low-Level softwarebeveiliging}
\section{Introductie}
Een \emph{implementation-level software vulnerability} is een fout in een programma die door een aanvaller kan worden misbruikt.
In dit hoofdstuk hebben we het concreet over \emph{memory corruption vulnerabilies}.
Deze zwakheden zijn enkel relevant voor onveilige talen.
Dat zijn programmeertalen die niet controleren of programma's het geheugen correct gebruiken.
Hieronder staat een voorbeeld in ANSI c in listing \ref{l:intro}. Omdat er nergens de lengte van de input argumenten wordt nagekeken kan men in geheugen schrijven waar dat niet zou mogen.
Op die manier kan er arbitraire code worden uitgevoerd (een \emph{code injection attack}).
 
\lstinputlisting[style=cstyle, label=l:intro]{\codeSrc/intro_example.c}

\subsection{Achtergrond informatie}
Er kan op verschillende manieren geheugen gealloceerd worden in C:
\begin{description}
	\item[Automatisch] via locale variablen in functies.	
	\item[Statisch] via globale variablen.	
	\item[Dynamisch] via \lstinline[style=cstyle]{void *malloc(size_t size);} en \lstinline[style=cstyle]{new}.
\end{description}
De programmeur is verantwoordelijk voor dit geheugenbeheer van het alloceren tot het de-alloceren.
Figuur \ref{f:mem_lay} geeft de \emph{process memory layout} weer van een programma.
Hierbij groeit de heap naar boven (hogere adressen) en de stack naar onder (lagere adressen).
Indien de voorbeeld code \ref{l:intro} wordt ge\"exploiteerd bevind de geinjecteerde code zich in de Stack.
\begin{figure}
\centering
\includegraphics{\imageSrc/memory_layout.png}
\caption{Typische geheugen layout met bovenaan \textbf{hoge} adressen. De stack groeit van hoge naar lage adressen en de heap van lage naar hoge adressen.}
\label{f:mem_lay}
\end{figure}

Memory management in C is zeer fout-gevoelig typische bugs zijn o.a.:
\begin{itemize}
		\item Writing past the bound of array (zoals in listing \ref{l:intro})
		\item Dangling pointers (pointers die niet naar een geldig object wijzen.)
		\item Double freeing (Twee keer \lstinline[style=cstyle]{free()} aanroepen zodat nog gebruikt geheughen als ongebruikt wordt gemarkeert).
		\item Memory leaks (Stukken geheugen zijn niet correct vrijgegeven.)
\end{itemize}
Om effici\"entie redenen worden deze fouten in C niet at run time gededecteert.

Om onveilige code aan te vallen moet een aanvaller hetvolgende doen:
\begin{itemize}
		\item Een bug vinden die memory safety breekt.
				\begin{itemize}
						\item Buffer overflow
						\item Dereference van dangling pointer
						\item Gebruik van onveilige API functie. Die ofwel een buffer overflowt (e.g. \lstinline[style=cstyle]{strcpy()} ofwel intrinsiek onveilig geimplementeerd is in assembly (e.g. \lstinline[style=cstyle]{printf()}
				\end{itemize}
		\item Een interessante geheugen plaats vinden om te overschrijven.
				\begin{itemize}
								\item Code adressen/pointers: Return address, Function pointer in Virtual function table, Programma specifieke fuction pointers
								\item Pointers waar de aanvaller kan controleren wat er wordt geschreven als die dereferenced raakt (= Indirect pointer overwrite): redirect de pointer naar een andere interessante locatie en schrijf dan daar een zekere waarde.
				\end{itemize}
		\item Aanvals code in het geheugen van het process plaatsen.
\end{itemize}

\section{Aanvals voorbeelden}
\subsection{Stack-based buffer overflow}
De stack is een geheugen gebied dat wordt gebruikt om functie oproepen en returns at run time te beheren.
Per oproep wordt er een \emph{activation record} of \emph{stack frame} op de stack gepusht. Daarin zitten parameters, return address, lokale variablen, \ldots
Het is eenvoudig in te zien dat als er nu een lokale variable kan worden overflowt dat er interessante geheugen plaatsen ter beschikking komen.

In de onderstaande figuren leggen we een typisch Stack Based Buffer Overflow uit. Opgelet ook hier weer veronderstellen we dat bovenaan hoge addressen staan en dus overflowt een buffer naar boven.
In figuur \ref{f:stackBO1} tonen we een normale (niet aangevallen) stack waarbij het laatste stackframe dat van functie f0 is. De instructiepointer (IP) aan het begin van f0 staat en de (Saved) Frame Pointer ((S)FP) en Stack Pointer (SP) staan aangeduid.
\begin{figure}
\centering
\includegraphics[scale=0.7]{\imageSrc/stackBO1.png}
\caption{Stack layout als de laatst opgeroepen functie f0 is.}
\label{f:stackBO1}
\end{figure}

Vervolgens in figuur \ref{f:stackBO2} wordt functie f1 opgeroepen. Een nieuw stackframe wordt op de stack gepusht. Let hierop dat in dit frame het return address nu wijst naar code net onder de call naar f1. De SFP wijst naar het frame van f0 en er daarachter plaats is voorzien voor de lokale variable \lstinline[style=cstyle]{buffer[]}. De stackpointer wijst natuurlijk net voorbij het frame van f1.
\begin{figure}
\centering
\includegraphics[scale=0.7]{\imageSrc/stackBO2.png}
\caption{Stack layout na call van functie f1.}
\label{f:stackBO1}
\end{figure}

In deze figuur wordt de overflow aangeduid. Als er geen bounds check gebeurdt kan de buffer blijven groeien en zo eerst de SFP, en dan het return address overschrijven. Door nu in het buffer uitvoerbarde code te steken en het return address naar die code te doen verwijzen kan er alles met het programma worden gedaan.
\begin{figure}
\centering
\includegraphics[scale=0.7]{\imageSrc/stackBO3.png}
\caption{Stack layout na buffer overflow attack op de lokale variable buffer in functie f1.}
\label{f:stackBO3}
\end{figure}
Het voorbeeld dat we in de introductie zagen (zie listing \ref{l:intro}) is een goed voorbeeld van een programma kwetsbaar voor een buffer overflow attack.

Code die vaak wordt gebruikt om te injecteren is het starten van een nieuwe shell.
Om dit te doen wordt er zogenaamde shellcode gebruikt.
Dit is een string van hexadecimale codes die dan worden geinterpreteerd als programma code.
Hieronder vind u een voorbeeld die op Linux systemen met een intel x86 architectuur kan gebruikt worden om de \emph{sh} shell te starten.

\begin{blockquote}
	"\textbackslash xeb\textbackslash x1f\textbackslash x5e\textbackslash x89\textbackslash x76\textbackslash x08\textbackslash x31\textbackslash xc0\textbackslash x88\textbackslash x46\textbackslash x07\textbackslash x89\textbackslash x46\textbackslash x0c\textbackslash xb0\textbackslash x0b \textbackslash x89\textbackslash xf3\textbackslash x8d\textbackslash x4e \\\textbackslash x08\textbackslash x8d\textbackslash x56\textbackslash x0c\textbackslash xcd \textbackslash x80\textbackslash x31\textbackslash xdb\textbackslash x89\textbackslash xd8\textbackslash x40\textbackslash xcd\textbackslash x80\textbackslash xe8\textbackslash xdc\textbackslash xff\textbackslash xff\textbackslash xffbin/sh"
\end{blockquote}

Om een stack based buffer overflow werkend te krijgen zijn er heel veel details waar de aanvaller rekening mee moet houden: O.a. 

\subsection{Heap-based buffer overflow}
Soms bevatten programmas enkel een overflowbare buffer die op de heap gealloceerd is.
Bijvoorbeeld globaal gedeclareerde structuren.
Aangezien die zich niet op de stack bevinden is er geen return address dicht bij.
Wel zijn er andere manieren om toch een succesvolle code injection attack te doen waarvan we er hier twee bekijken: overwriting function pointer en overwriting heap metadata.
\subsubsection{Overwriting function pointer}
In listing \ref{l:heapBO} staat een programma dat kwetsbaar is voor een heap based buffer overflow door middel van een function pointer te overschrijven. 
\lstinputlisting[style=cstyle, label=l:heapBO]{\codeSrc/heapBO.c}

Figuur \ref{f:heapBO1} toont hoe de vulnerability wordt uitgebuit.
In (a) zien we de opeenvolgende adressen van de struct en de waardes die ze initieel krijgen toegekent.
In (b) zien we hoe er een overflow kan worden gerealiseerd die cmp overschrijft.

Let hierbij op het feit dat de waardes in Little Endian worden opgeslagen.
Dit betekend dat de eerste byte van een geheugenlocatie de meest rechtse positie krijgt.
We kunnen dit makkelijk zien door het einde van het voorbeeld (b)te bekijken. De laatste drie characters van de string zijn ``sdf''.
We weten dat ``s'' overeenkomt met het hexadecimale ``73'', d met ``64'' en f met ``66''.

Als we nu naar de geheugen locatie van cmp (\emph{0x00353078}) kijken dan vinden we daar \emph{0x00666473}. 
Tabel
\begin{table}
\centering 
\begin{tabular}{l|cccc|}
		Geheugen plaats (hex) & 0x0035307b & 0x0035307a & 0x00353079 & 0x00353078 \\ \hline
		Geheugen waarde (hex) & 00 & 66 & 64 & 73 \\ \hline
		Character (string representatie) & n/a & f & d & s \\ \hline   
\end{tabular}
\end{table}

\begin{figure}
\centering
\includegraphics[scale=0.7]{\imageSrc/heapBO1.png}
\caption{Stack layout na buffer overflow attack op de lokale variable buffer in functie f1.}
\label{f:heapBO1}
\end{figure}

\subsubsection{Overwriting heap metadata}
De heap wordt gebruikt om dynamisch gealloceerde data op te slaam.
Met functies zoals \lstinline[style=cstyle]{malloc()} worden er dynamisch geheugenblokken gealloceerd en gedealloceerd met \lstinline[style=cstyle]{free()}.
De meest memory allocation libraries onthouden metadata voor of achter gebruikte blokken.
Een gevolg daarvan is dat buffer overruns op de heap deze management informatie kunnen overschrijven.
Dit maakt een \emph{indirect pointer overwrite} aanval mogelijk. 
\subsection{Return-to-libc attacks}
\subsection{Data-only attacks}
\section{Verdedigings voorbeelden}
\subsection{Stack canaries}
\subsection{Non-executable data}
\subsection{Control-flow integrity}
\subsection{Layout randomization}
\section{Conclusie}
\end{document}
